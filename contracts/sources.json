{
  "Application.sol": "pragma solidity ^0.4.13;\n\ncontract Application {\n\n    function submitApplication(address _applicant);\n    function withdrawApplication(address _applicant);\n    function hasOpenApplication(address _applicant) constant returns (bool);\n\n}",
  "ApplicationSource.sol": "pragma solidity ^0.4.13;\n\ncontract ApplicationSource {\n\n    function applicationApproved(address _applicant, address _approver);\n\n    function applicationRejected(address _applicant, address _approver);\n\n}",
  "EthApplicationRegistrar.sol": "pragma solidity ^0.4.13;\n\nimport \"./owned.sol\";\nimport \"./ExpiringMembership.sol\";\nimport \"./ApplicationSource.sol\";\nimport \"./Application.sol\";\n\n/**\n * This contract connects to an ExpiringMembership contract and allows the purchase\n * of membership tokens using Ether\n */\ncontract EthApplicationRegistrar is ApplicationSource, owned {\n\n    event PriceChanged(address owner, uint oldPrice, uint newPrice);\n    event DurationChanged(address owner, uint oldDuration, uint newDuration);\n    event MembershipRequested(address member, uint price);\n    event MembershipPurchased(address member, uint price, uint duration, uint expiry);\n    event MembershipRejected(address member, uint refunded);\n    event MembershipRequestWithdrawn(address member, uint refunded);\n    event FundsWithdrawn(address account, uint amount, uint balance);\n\n    /**\n     * The address where we are purchasing membership tokens at\n     */\n    ExpiringMembership public membershipContract;\n\n    /**\n     * The price for purchasing membership using this contract\n     */\n    uint public price;\n\n    /**\n     * The length of time membership, purchased with this contract, will last\n     */\n    uint public duration;\n\n    /**\n     * Address for the contract which managing applications\n     */\n    Application public applications;\n\n    /**\n     * Eschrowed balances in wei\n     */\n    mapping(address => uint) public escrow;\n\n    /**\n     * The withdrawable balances for various addresses in wei\n     */\n    mapping(address => uint) public balance;\n\n    modifier byApplicationsContract() {\n        assert(msg.sender == address(applications));\n        _;\n    }\n\n    function EthApplicationRegistrar(ExpiringMembership _membershipContract, Application _applications, uint _price, uint _duration) {\n        owner = msg.sender;\n        membershipContract = _membershipContract;\n        applications = _applications;\n        price = _price;\n        duration = _duration;\n    }\n\n    function changePrice(uint _price) byOwner {\n        PriceChanged(msg.sender, price, _price);\n        price = _price;\n    }\n\n    function changeDuration(uint _duration) byOwner {\n        DurationChanged(msg.sender, duration, _duration);\n        duration = _duration;\n    }\n\n    /**\n     * Purchase a single membership token using Ether. The funds will be placed in escrow first and an application is opened.\n     * The application will be opened if the message contains the amount of Ether indicated by the price, another application is not already\n     * open and any one of the following:\n     * 1. The message sender (or payer) is not a member of the organisation already.\n     * 2. The message sender is a member of the organisation already but their membership\n     *    is closed to expire as defined by the isMembershipAllowed() function\n     */\n    function purchaseMembership() payable {\n        assert(isMembershipAllowed(msg.sender));\n        assert(!applications.hasOpenApplication(msg.sender));\n        assert(msg.value == price);\n        escrow[msg.sender] += price;\n        applications.submitApplication(msg.sender);\n        MembershipRequested(msg.sender, price);\n    }\n\n    function withdrawApplication() {\n        assert(applications.hasOpenApplication(msg.sender));\n        var paid = escrow[msg.sender];\n        escrow[msg.sender] -= paid;\n        balance[msg.sender] += paid;\n        applications.withdrawApplication(msg.sender);\n        MembershipRequestWithdrawn(msg.sender, paid);\n    }\n\n    /**\n     * Lets anyone withdraw any funds due to them from this contract\n     */\n    function withdraw(uint _amount) {\n        assert(_amount <= balance[msg.sender]);\n        balance[msg.sender] -= _amount;\n        msg.sender.transfer(_amount);\n        FundsWithdrawn(msg.sender, _amount, balance[msg.sender]);\n    }\n\n    /**\n     * Determines whether the given address is allowed to purchase membership. This is true\n     * if the address is not already a member of the organisation OR the expiry timestamp\n     * is within the renewal period (ie. 30 days before expiry).\n     */\n    function isMembershipAllowed(address _member) constant returns (bool) {\n        var expiryDate = membershipContract.getMembershipExpiryDate(_member);\n        return expiryDate == 0 || now >= expiryDate - 30 days;\n    }\n\n    function applicationApproved(address _applicant, address _approver) byApplicationsContract {\n        var paid = escrow[_applicant];\n        escrow[_applicant] -= paid;\n        balance[owner] += paid;\n        membershipContract.enroll(_applicant, duration);\n        MembershipPurchased(_applicant, paid, duration, membershipContract.getMembershipExpiryDate(_applicant));\n    }\n\n    function applicationRejected(address _applicant, address _approver) byApplicationsContract {\n        var paid = escrow[_applicant];\n        escrow[_applicant] -= paid;\n        balance[_applicant] += paid;\n        MembershipRejected(msg.sender, paid);\n    }\n\n}",
  "ExpiringMembership.sol": "pragma solidity ^0.4.13;\n\nimport \"./owned.sol\";\n\n/**\n * This smart contract keeps whether addresses are part of an organisation. Membership will expire\n * after a certain time unless it is renewed.\n */\ncontract ExpiringMembership is owned {\n\n    event RegistrarAdded(address indexed owner, address indexed registrar, string description);\n    event RegistrarRemoved(address indexed owner, address indexed registrar);\n    event NewMemberRegistered(address indexed member, address indexed registrar, uint duration, uint expiryTimestamp);\n    event MembershipExtended(address indexed member, address indexed registrar, uint duration, uint expiryTimestamp);\n    event MembershipRevoked(address indexed member, address indexed revoker);\n\n    /**\n     * Membership status of an address. Currently only contains the expiry timestamp\n     * of that membership.\n     */\n    struct Membership {\n        uint expiryTimestamp;\n    }\n\n    /**\n     * Which addresses are considered registrars. These addresses can be personal\n     * accounts or can even be other smart contracts (like the EtherPaymentRegistrar).\n     */\n    mapping(address => bool) public isRegistrar;\n\n    /**\n     * Membership status for Ethereum addresses\n     */\n    mapping(address => Membership) public members;\n\n    /**\n     * Checks that the transaction source is a registrar or this contract's owner\n     */\n    modifier hasRegistrationPrivileges() {\n        require(msg.sender == owner || isRegistrar[msg.sender]);\n        _;\n    }\n\n    /*\n     * Checks that the specified address is currently a member\n     */\n    modifier member(address _member) {\n        require(isMember(_member));\n        _;\n    }\n\n    function ExpiringMembership() {\n        owner = msg.sender;\n    }\n\n    /**\n     * Allows this contract's owner to add a new registrar. The description is\n     * stored in this contract's event log.\n     */\n    function addRegistrar(address _registrar, string description) byOwner {\n        if (isRegistrar[_registrar]) {\n            return;\n        }\n        isRegistrar[_registrar] = true;\n        RegistrarAdded(msg.sender, _registrar, description);\n    }\n\n    /**\n     * Allows this contract's owner to remove a registrar.\n     */\n    function removeRegistrar(address _registrar) byOwner {\n        if (!isRegistrar[_registrar]) {\n            return;\n        }\n        isRegistrar[_registrar] = false;\n        RegistrarRemoved(msg.sender, _registrar);\n    }\n\n    /**\n     * Register or renew an address' membership. The membership token will last\n     * for the given duration amount. When renewing a membership, the expiry date\n     * will be EXTENDED and added to whatever the previous expiry date.\n     *\n     * This function can only be invoked by registrars or this contract's owner.\n     */\n    function enroll(address _member, uint duration) hasRegistrationPrivileges {\n        if (isMember(_member)) {\n           extendMembership(_member, duration);\n        } else {\n           registerNewMember(_member, duration);\n        }\n    }\n\n    /**\n     * Immediately revoke a member's membership.  This function can only be invoked\n     * by registrars or this contract's owner\n     */\n    function revoke(address _member) hasRegistrationPrivileges {\n        assert(isMember(_member));\n        members[_member].expiryTimestamp = now;\n        MembershipRevoked(_member, msg.sender);\n    }\n\n    function extendMembership(address _member, uint duration) private {\n        var expiry = members[_member].expiryTimestamp + duration;\n        members[_member].expiryTimestamp = expiry;\n        MembershipExtended(_member, msg.sender, duration, expiry);\n    }\n\n    function registerNewMember(address _member, uint duration) private {\n        var expiry = now + duration;\n        members[_member].expiryTimestamp = expiry;\n        NewMemberRegistered(_member, msg.sender, duration, expiry);\n    }\n\n    /**\n     * Checks whether the specified address is currently a member\n     */\n    function isMember(address _member) constant returns (bool) {\n        return now <= getMembershipExpiryDate(_member);\n    }\n\n    /**\n     * Returns the expiry timestamp of the specified address' membership. If the\n     * returned value is 0, that address was never a member\n     */\n    function getMembershipExpiryDate(address _member) constant returns (uint) {\n        return members[_member].expiryTimestamp;\n    }\n\n}",
  "Migrations.sol": "pragma solidity ^0.4.13;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function Migrations() {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
  "SingleApproval.sol": "pragma solidity ^0.4.13;\n\nimport \"./owned.sol\";\nimport \"./Application.sol\";\nimport \"./ApplicationSource.sol\";\n\n/**\n * This contract defines the concept of applications and approvals. An application can be withdrawn by its source.\n *\n * - Application Sources: A set of addresses that can submit applications for approval.\n * - Applicant: The address on whose behalf the application is being made.\n * - Approvers: A set of addresses that can approve applications.\n */\ncontract SingleApproval is Application, owned {\n\n    event ApproverAdded(address indexed owner, address indexed approver, string description);\n    event ApproverRemoved(address indexed owner, address indexed approver);\n    event ApplicationSourceAdded(address indexed owner, address indexed source, string description);\n    event ApplicationSourceRemoved(address indexed owner, address indexed source);\n    event ApplicationSubmitted(address indexed source, address indexed applicant);\n    event ApplicationWithdrawn(address indexed source, address indexed applicant);\n    event ApplicationRejected(address indexed approver, address indexed source, address indexed applicant, string description);\n    event ApplicationApproved(address indexed approver, address indexed source, address indexed applicant, string description);\n\n    mapping(address => bool) public sources;\n\n    mapping(address => bool) public approvers;\n\n    /**\n     * Contains all the open applications currently available\n     */\n    mapping(address => mapping(address => bool)) public applications;\n\n    modifier hasApplicationRights() {\n        require(sources[msg.sender] || msg.sender == owner);\n        _;\n    }\n\n    modifier hasApprovalRights() {\n        require(approvers[msg.sender] || msg.sender == owner);\n        _;\n    }\n\n    function SingleApproval() {\n        owner = msg.sender;\n    }\n\n    function addApprover(address _approver, string description) byOwner {\n        if (approvers[_approver]) {\n            return;\n        }\n        approvers[_approver] = true;\n        ApproverAdded(msg.sender, _approver, description);\n    }\n\n    function removeApprover(address _approver) byOwner {\n        if (!approvers[_approver]) {\n            return;\n        }\n        approvers[_approver] = false;\n        ApproverRemoved(msg.sender, _approver);\n    }\n\n    function addApplicationSource(ApplicationSource _source, string description) byOwner {\n        if (sources[_source]) {\n            return;\n        }\n        sources[_source] = true;\n        ApplicationSourceAdded(msg.sender, _source, description);\n    }\n\n    function removeApplicationSource(ApplicationSource _source) byOwner {\n        if (!sources[_source]) {\n            return;\n        }\n        sources[_source] = false;\n        ApproverRemoved(msg.sender, _source);\n    }\n\n    function submitApplication(address _applicant) hasApplicationRights {\n        var source = msg.sender;\n        assert(!applications[source][_applicant]);\n        applications[source][_applicant] = true;\n        ApplicationSubmitted(source, _applicant);\n    }\n\n    function withdrawApplication(address _applicant) hasApplicationRights {\n        var source = msg.sender;\n        assert(applications[source][_applicant]);\n        applications[source][_applicant] = false;\n        ApplicationWithdrawn(source, _applicant);\n    }\n\n    function hasOpenApplicationFromSource(address source, address _applicant) constant returns (bool) {\n        return applications[source][_applicant];\n    }\n\n    function hasOpenApplication(address _applicant) constant returns (bool) {\n        return hasOpenApplicationFromSource(msg.sender, _applicant);\n    }\n\n    function rejectApplication(ApplicationSource _source, address _applicant, string description) hasApprovalRights {\n        assert(applications[_source][_applicant]);\n        applications[_source][_applicant] = false;\n        ApplicationRejected(msg.sender, _source, _applicant, description);\n        _source.applicationRejected(_applicant, msg.sender);\n    }\n\n    function approveApplication(ApplicationSource _source, address _applicant, string description) hasApprovalRights {\n        assert(applications[_source][_applicant]);\n        applications[_source][_applicant] = false;\n        ApplicationApproved(msg.sender, _source, _applicant, description);\n        _source.applicationApproved(_applicant, msg.sender);\n    }\n\n}",
  "owned.sol": "pragma solidity ^0.4.13;\n\ncontract owned {\n\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    address public owner;\n\n    modifier byOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function changeOwner(address _owner) byOwner {\n        owner = _owner;\n        OwnerChanged(msg.sender, _owner);\n    }\n\n}"
}